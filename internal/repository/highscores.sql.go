// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: highscores.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllHighScores = `-- name: GetAllHighScores :many

SELECT 
    game_session_id
    , username 
    , width
    , height
    , mine_count
    , "unique"
    , (
        extract('epoch' from ended_at) - extract('epoch' from started_at)
    ) * 1000 playtime_ms
FROM game_session
    LEFT OUTER JOIN player using (player_id)
WHERE 
    won = true 
    AND dead = false 
    AND ended_at IS NOT NULL
`

type GetAllHighScoresRow struct {
	GameSessionID int64       `json:"game_session_id"`
	Username      pgtype.Text `json:"username"`
	Width         int32       `json:"width"`
	Height        int32       `json:"height"`
	MineCount     int32       `json:"mine_count"`
	Unique        bool        `json:"unique"`
	PlaytimeMs    int32       `json:"playtime_ms"`
}

func (q *Queries) GetAllHighScores(ctx context.Context) ([]GetAllHighScoresRow, error) {
	rows, err := q.db.Query(ctx, getAllHighScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllHighScoresRow
	for rows.Next() {
		var i GetAllHighScoresRow
		if err := rows.Scan(
			&i.GameSessionID,
			&i.Username,
			&i.Width,
			&i.Height,
			&i.MineCount,
			&i.Unique,
			&i.PlaytimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighScoresForGameParams = `-- name: GetHighScoresForGameParams :many

SELECT 
    game_session_id
    , username 
    , width
    , height
    , mine_count
    , "unique"
    , (
        extract('epoch' from ended_at) - extract('epoch' from started_at)
    ) * 1000 playtime_ms
FROM game_session
    LEFT OUTER JOIN player using (player_id)
WHERE 
    won = true 
    AND dead = false 
    AND ended_at IS NOT NULL
    AND width = $1
    AND height = $2
    AND mine_count = $3
    AND "unique" = $4
`

type GetHighScoresForGameParamsParams struct {
	Width     int32 `json:"width"`
	Height    int32 `json:"height"`
	MineCount int32 `json:"mine_count"`
	Unique    bool  `json:"unique"`
}

type GetHighScoresForGameParamsRow struct {
	GameSessionID int64       `json:"game_session_id"`
	Username      pgtype.Text `json:"username"`
	Width         int32       `json:"width"`
	Height        int32       `json:"height"`
	MineCount     int32       `json:"mine_count"`
	Unique        bool        `json:"unique"`
	PlaytimeMs    int32       `json:"playtime_ms"`
}

func (q *Queries) GetHighScoresForGameParams(ctx context.Context, arg GetHighScoresForGameParamsParams) ([]GetHighScoresForGameParamsRow, error) {
	rows, err := q.db.Query(ctx, getHighScoresForGameParams,
		arg.Width,
		arg.Height,
		arg.MineCount,
		arg.Unique,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighScoresForGameParamsRow
	for rows.Next() {
		var i GetHighScoresForGameParamsRow
		if err := rows.Scan(
			&i.GameSessionID,
			&i.Username,
			&i.Width,
			&i.Height,
			&i.MineCount,
			&i.Unique,
			&i.PlaytimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighScoresForUsername = `-- name: GetHighScoresForUsername :many

SELECT 
    game_session_id
    , username 
    , width
    , height
    , mine_count
    , "unique"
    , (
        extract('epoch' from ended_at) - extract('epoch' from started_at)
    ) * 1000 playtime_ms
FROM game_session
    LEFT OUTER JOIN player using (player_id)
WHERE 
    won = true 
    AND dead = false 
    AND ended_at IS NOT NULL
    AND username = $1
`

type GetHighScoresForUsernameRow struct {
	GameSessionID int64       `json:"game_session_id"`
	Username      pgtype.Text `json:"username"`
	Width         int32       `json:"width"`
	Height        int32       `json:"height"`
	MineCount     int32       `json:"mine_count"`
	Unique        bool        `json:"unique"`
	PlaytimeMs    int32       `json:"playtime_ms"`
}

func (q *Queries) GetHighScoresForUsername(ctx context.Context, username string) ([]GetHighScoresForUsernameRow, error) {
	rows, err := q.db.Query(ctx, getHighScoresForUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighScoresForUsernameRow
	for rows.Next() {
		var i GetHighScoresForUsernameRow
		if err := rows.Scan(
			&i.GameSessionID,
			&i.Username,
			&i.Width,
			&i.Height,
			&i.MineCount,
			&i.Unique,
			&i.PlaytimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighScoresForUsernameAndGameParams = `-- name: GetHighScoresForUsernameAndGameParams :many

SELECT 
    game_session_id
    , username 
    , width
    , height
    , mine_count
    , "unique"
    , (
        extract('epoch' from ended_at) - extract('epoch' from started_at)
    ) * 1000 playtime_ms
FROM game_session
    LEFT OUTER JOIN player using (player_id)
WHERE 
    won = true 
    AND dead = false 
    AND ended_at IS NOT NULL
    AND username = $1
    AND width = $2
    AND height = $3
    AND mine_count = $4
    AND "unique" = $5
`

type GetHighScoresForUsernameAndGameParamsParams struct {
	Username  string `json:"username"`
	Width     int32  `json:"width"`
	Height    int32  `json:"height"`
	MineCount int32  `json:"mine_count"`
	Unique    bool   `json:"unique"`
}

type GetHighScoresForUsernameAndGameParamsRow struct {
	GameSessionID int64       `json:"game_session_id"`
	Username      pgtype.Text `json:"username"`
	Width         int32       `json:"width"`
	Height        int32       `json:"height"`
	MineCount     int32       `json:"mine_count"`
	Unique        bool        `json:"unique"`
	PlaytimeMs    int32       `json:"playtime_ms"`
}

func (q *Queries) GetHighScoresForUsernameAndGameParams(ctx context.Context, arg GetHighScoresForUsernameAndGameParamsParams) ([]GetHighScoresForUsernameAndGameParamsRow, error) {
	rows, err := q.db.Query(ctx, getHighScoresForUsernameAndGameParams,
		arg.Username,
		arg.Width,
		arg.Height,
		arg.MineCount,
		arg.Unique,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighScoresForUsernameAndGameParamsRow
	for rows.Next() {
		var i GetHighScoresForUsernameAndGameParamsRow
		if err := rows.Scan(
			&i.GameSessionID,
			&i.Username,
			&i.Width,
			&i.Height,
			&i.MineCount,
			&i.Unique,
			&i.PlaytimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
